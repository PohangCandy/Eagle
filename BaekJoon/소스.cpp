//아이디어
// 오우 쉣..풀다보니 dfs로는 안될 것 같다. 
// 하나의 노드에서 전체를 탐방하는 것이 아니라,
// 전체를 부분집합으로 나눠야 한다.
// 문제의 핵심은 
// 가로로 묶인 집합과 세로로 묶인 집합을 각각 어떻게 표현할 것인가이다.
// 이를 비트마스크를 이용해서
// 0을 가로로 묶인 집합, 1을 세로로 묶인 집합으로 나타낸다.

//시간복잡도
// 16 비트를 각각 나타내는 경우의 수 2^16 = 약 10^5
// 여기에 쓰여진 각 숫자를 탐방하므로 *16, 
// 총 약 10^6

#include <iostream>
using namespace std;

int arr[4][4];

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int result = 0;

	int N, M;
	cin >> N >> M;

	for (int i = 0; i < N; i++)
	{
		string input;
		cin >> input;

		for (int j = 0; j < M; j++)
		{
			arr[i][j] = input[j] - '0';
		}
	}

	// N * M개의 비트를 가지고 비트를 짠다.
	// 가로 배열이 양 옆에 붙어있는 경우
	// 현재 값 * 10 + 새로운 가로 배열의 값
	// 중간에 세로 배열이 나타날 경우 
	// 총합에 현재값을 더한 후, 현재 값을 0으로 초기화

	for (int i = 0; i < (1 << (N * M)); i++)
	{
		//가로 세로 집합의 총합을 저장할 변수
		int total = 0;

		//가로로 묶여있는 값들 먼저 계산한다.
		//기로 집합은 각 줄마다 더해지므로
		for (int j = 0; j < N; j++)
		{
			int sum = 0;
			for (int k = 0; k < M; k++)
			{
				//현재 비트가 세로 집합이라면
				//현재 값을 총합에 더하고, 초기화킨다.
				if (i & (1 << (j * M + k)))
				{
					total += sum;
					sum = 0;
				}
				//가로 집합이라면
				//지금까지 이어진 가로 집합 *10 + 현재 값
				else
				{
					sum = sum * 10 + arr[j][k];
				}
			}
			//마지막 줄이 가로로 끝난 경우
			//총합에 sum을 더한다.
			total += sum;
		}


		//세로로 묶여있는 값 들을 계산한다.
		//세로 집합은 각 줄마다 더해지므로
		for (int j = 0; j < M; j++)
		{
			int sum = 0;
			for (int k = 0; k < N; k++)
			{
				//현재 비트가 세로 집합이라면
				// 지금까지 이어진 세로 집합 *10 + 현재 값
				if (i & (1 << (k * M + j)))
				{
					sum = sum * 10 + arr[k][j];
				}
				//가로 집합이라면
				//현재 값을 총합에 더하고, 초기화킨다.
				else
				{
					total += sum;
					sum = 0;
				}
			}
			//마지막 줄이 세로로 끝난 경우
			//총합에 sum을 더한다.
			total += sum;
		}

		//주어진 비트에서 계산된 총 합의 최댓값이 정답이 된다.
		result = max(result, total);
	}

	cout << result;

	return 0;
}
