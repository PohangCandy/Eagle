#include <iostream>
using namespace std;

// tile[n] , 3*n에 타일을 까는 경우의 수
// 
// 3 * n의 타일을 채운다고 가정했을때
// n%2 == 1이라면, 블록으로 다 채울 수 없음으로 0을 출력해준다.

// n%2 == 0일 경우, 
// 3 * 2타일을 채우는 경우의 수는 3가지이다.
// tile[2] = 3;
// 
// 3 * 4의 타일을 채우는 경우
// 3*2 타일과 3*2타일로 구분했을때 나올 수 있는 경우의 수는 3*3 = 9가지이다.
// 여기에 추가적으로 두 블록의 경게를 구분짓지 않고 들어올수 있는 2가지 모양이 더 있다.
// tile[4] = tile[2] * tile[2] + 2

// 3 * 6의 타일을 채우는 경우는
// 3*2 + 3*4, 3* 4 + 3*2, 3*6으로 나눌 수 있다.
// 이들 각각이 중복되지 않으려면
// 3*2 + 3*4에서는 끝에 3* 4 + 3*2와 마찬가지로 3*2형태로 끝나면 안되는 경우이다.
// 즉, 3*4의 형태가 두 블록의 경계를 구분짓지 특이한 모양 2가지일 경우이다.
// 그리고 추가적으로 2가지의 트깅한 모양이 있다.
// 
// tile[6] = tile[4] * tile[2] + tile[2] * 2 + 2

//  3 * 8의 타일을 채우는 경우
// 3*2 + 3*6, 3* 4 + 3*4, 3*6 + 3*2, 3 * 8으로 나눌 수 있다.
// 이들 각각이 중복되지 않으려면
// 3* 4 + 3*4는 3*2형태로 끝나면 안된다.
// 3*2 + 3*6는 3*4나 3*2형태로 끝나면 안된다.
// tile[8] = tile[6] * tile[2] + tile[4] * 2 + tile[2] * 2 + 2

//이를 점화식으로 나타내준다.
//tile[n] = tile[n-2] * tile[2] + tile[n-4] * 2 + ... + 2이므로
//tile[0] = 1, 2 = tile[0] * 2으로 작성해준다.
int tile[31];

int RR(int tile[],int n)
{
	tile[0] = 1;
	tile[1] = 0;
	tile[2] = 3;
	tile[3] = 0;
	for (int i = 4; i <= n; i++)
	{
		if (i % 2 != 0)
		{
			tile[i] = 0;
			continue;
		}

		tile[i] = tile[i - 2] * tile[2];
		for (int j = i - 4; j >= 0; j -= 2)
		{
			tile[i] += tile[j] * 2;
		}
	}

	return tile[n];
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int n;
	cin >> n;

	cout << RR(tile, n);

	return 0;
}