// 10,10
// 1,11
// 2,1
// ...
// M,N
// 1~10시까지 있는 시계와 1~12시까지 있는 시계
// 각 시계가 1,1로 시작해서 10,12까지 움직인다고 할 때
// 주어진 x,y가 몇번째에 해당하는지 나타내라.


#include <iostream>
using namespace std;
// 아이디어
// <1,1>부터 <M,N>이 나오도록 
// i를 증가시켜가며 나머지 연산을 하여
// x,y가 되면 몇번째인지 출력하고
// 없으면 -1을 출력한다.
// 노가다로 찾으면 되지 않을까?
// 
// 하나의 값을 먼저 찾으면 어떨까?
// 만약 M이 10이고 x가 3이라면
// x가 될 수 있는 값은 13,23,33등이다.
// 총 M * N개의 수 중에서 M * N / M개로 추릴 수 있다.
// 여기선 '해'라고 표시하지만 해석하면 단순한 값이 된다.
// 33번째 해는 33을 10과 12로 나눈 나머지가 3,9라는 듯이다.
// 그러므로 입력받은 M * N의 최소 공배수를 찾고
// 그 안에서 x,y를 만족하는 값을 찾는다.
// 그러면 시간복잡도도 N만큼 줄일 수 있다.
// 
// 시간복잡도
// 1 1 - > 1 1
// 
// 2 2 -> 1 1, 2 2
// 
// 2 3 -> 1 1, 2 2, 1 3, 2 1, 1 2, 2 3
// 
// 4 2 -> 
// 1 1, 2 2
// 3 1, 4 2
// 
// 4 3 -> 
// 1 1, 2 2, 3 3
// 4 1,1 2, 2 3,
// 3 1, 4 2, 1 3,
// 2 1, 3 2, 4 3
// 
// M과 N의 최소공배수까지 반복한다.
// 40000 * 40000 = 16 * 10^8 -> 노가다를 통해 찾을 경우 시간초과가 날 것임을 알 수 있다.
//
//
// M * N의 최소공배수를 찾는다.
// 최소 공배수 = M * N / 최대공약수 이다.
// 먼저 최대공약수를 찾으면 최소공배수를 구할 수 있다.
//

// 메모리
//

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);



	return 0;
}