#include <iostream>
using namespace std;
// 포도주를 연속으로 3잔 마실 순 없다.
// 놓여있는 포도주를 최대한 많이 먹자.
// 1잔 놓여있는 경우
// 6 -> 6
// 2잔 놓여있는 경우
// 6 6 -> 12
//3잔 놓여있는 경우
// 6 6 10
// 각 잔의 순서에 따라 1,2,3으로 표현한다.
// 1,2 1,3 2,3중에 가장 많은 값을 찾는다.
// 앞에 두잔을 선택하는 경우, 앞에서 한잔, 뒤에서 한잔 고르는 경우
// 놓여진 n개의 잔에서 최대로 마실 수 있는 와인의 양을 배열에 저장한다면
// arr[1][1] , 1잔중에 1잔 마실때 마실 수 있는 최대 양
// arr[1][1] = arr[1][1]
// arr[2][2] = arr[1][1] + arr[2][1]
// arr[2][1] = max(arr[1][1],arr[2][1])
// arr[3][2] = max(arr[2][2],arr[3][1] + arr[2][1])
// 
// 문제는 연속 3잔이다..
// 3칸씩 끊어서 생각해본다.
// 첫 칸에서 1,2잔을 마시는 경우를 [1][1]이라고 할 때
// 두번째 칸에서는 1,2잔을 마셔도 되고
// 1,3잔, 2,3잔을 마셔도 된다.
// 첫 칸에서 1,3잔을 마시는 경우를 [1][2]라고 할 때
// 두번째 칸에서는 1,3잔, 2,3잔을 마실 수 있다.
// 첫 칸에서 2,3잔을 마시는 경우를 [1][3]라고 할 때
// 두번째 칸에서는 1,3잔, 2,3잔을 마실 수 있다.
// 
// 포도주의 양을 저장하고 있는 배열을 하나 만들어둔다.
// orgin[n]
// 포도주의 양을 합쳐서 저장할 배열을 하나 만든다.
// arr[n/3 + 1][4]
// arr[1][1] = orgin[1] + orgin[2];
// arr[1][2] = orgin[1] + orgin[3];
// arr[1][3] = orgin[2] + orgin[3];
// arr[2][1] = orgin[1+3] + orgin[2+3] + arr[1][1]
// arr[2][2] = orgin[1+3] + orgin[3+3] + max(arr[1][1],arr[1][2])
// arr[2][3] = orgin[2+3] + orgin[3+3] + max(arr[1][1],arr[1][2],arr[1][3])

// 칸 수 마다 항상 2잔씩 마셔야 최대가 되지 않는다.
// 1,10,10,1,10,1,10,10,1일 경우 
// x o o/x o x/o o x형식으로 마셔야된다.
// 즉 3칸마다 ox가 올 수 있는 형식인 2*2*2 = 8가지 형태에 대한 최댓값을 모두 구해야한다.
// 각 칸에서 한잔도 안마시는 경우와 3잔 마시는 경우는 없으므로
// ooo, xxx를 제외한 6가지 형태를 구한다.

int arr[10000/3 + 1][8];

int RR(int arr[][8],int n)
{

	for (int i = 1; i <= n; i++)
	{
		int frist = arr[i][0];
		int second = arr[i][1];
		int third = arr[i][2];

		arr[i][0] = third;//001
		arr[i][1] = second;//010
		arr[i][2] = second + third;//011

		arr[i][3] = frist;//100
		arr[i][4] = frist + third;//101

		arr[i][5] = frist + second;//110

		if (i == 1) continue;
		//i번째 칸에서 첫번째 잔을 안마시는 경우(001,010,011)
		//이전 칸에서 어떤 식으로 마시든 상관없다.
		//가장 최댓값으로 더해준다.
		int m = max(max(max(max(max(arr[i - 1][0], arr[i - 1][1]), arr[i - 1][2]), arr[i - 1][3]), arr[i - 1][4]), arr[i - 1][5]);
		arr[i][0] += m;
		arr[i][1] += m;
		arr[i][2] += m;
		//i번째 칸에서 첫번째 잔만 마시는 경우(100,101)
		//이전 칸에서 2,3번째 잔을 연속으로 마시는 경우를 제외하고 다 가능하다.arr[i - 1][2](011)
		//가장 최댓값으로 더해준다.
		m = max(max(max(max(arr[i - 1][0], arr[i - 1][1]), arr[i - 1][3]), arr[i - 1][4]), arr[i - 1][5]);
		arr[i][3] += m;
		arr[i][4] += m;
		//i번째 칸에서 첫번째,두번째 잔을 모두 마시는 경우(110)
		//이전 칸에서 3번째 잔을 마시는 경우를 제외하고 가능하다.(010,100,110)
		//가장 최댓값으로 더해준다.
		m = max(max(arr[i - 1][1], arr[i - 1][3]), arr[i - 1][5]);
		arr[i][5] += m;
	}

	//마지막 칸에서 어떤 잔을 비워야 최대가 되는지 최댓값을 찾는다.
	return max(max(max(max(max(arr[n][0], arr[n][1]), arr[n][2]), arr[n][3]), arr[n][4]), arr[n ][5]);
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int n;
	cin >> n;
	for(int i = 0; i < n; i++)
	{
	  int input;
	  cin >> input;
	  arr[i/3 + 1][i % 3] = input;
	}

	cout << RR(arr, (n / 3)+1);

	return 0;
}